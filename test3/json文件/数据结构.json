{"基本操作": {"key": ["基本操作"], "property": ["subclassof"], "to_name": ["name"], "重要程度": [3], "所属章节": [], "知识点描述": []}, "二叉树的遍历": {"key": ["二叉树的遍历"], "property": ["type"], "to_name": ["基本操作"], "重要程度": [4], "所属章节": ["6"], "知识点描述": ["二叉树的遍历（traversing binary tree）是指从根结点出发，按照某种次序依次访问二叉树中所有的结点，使得每个结点被访问依次且仅被访问一次。\n四种遍历方式分别为：先序遍历、中序遍历、后序遍历、线索化二叉树。"]}, "先序遍历二叉树": {"key": ["先序遍历二叉树"], "property": ["subclassof"], "to_name": ["二叉树的遍历"], "重要程度": [4], "所属章节": ["6"], "知识点描述": ["先序遍历(Pre-order)，按照根左右的顺序沿一定路径经过路径上所有的结点。在二叉树中，先根后左再右。巧记：根左右。"]}, "中序遍历二叉树": {"key": ["中序遍历二叉树"], "property": ["subclassof"], "to_name": ["二叉树的遍历"], "重要程度": [4], "所属章节": ["6"], "知识点描述": ["中序遍历(LDR)是二叉树遍历的一种，也叫做中根遍历、中序周游。在二叉树中，中序遍历首先遍历左子树，然后访问根结点，最后遍历右子树。巧记：左根右。"]}, "后序遍历二叉树": {"key": ["后序遍历二叉树"], "property": ["subclassof"], "to_name": ["二叉树的遍历"], "重要程度": [4], "所属章节": ["6"], "知识点描述": ["后序遍历(LRD)是二叉树遍历的一种，也叫做后根遍历、后序周游。后序遍历有递归算法和非递归算法两种。巧记：左右根。"]}, "图的遍历": {"key": ["图的遍历"], "property": ["type"], "to_name": ["基本操作"], "重要程度": [4], "所属章节": ["7"], "知识点描述": ["图的遍历指的是从图中的任一顶点出发，对图中的所有顶点访问一次且只访问一次。"]}, "深度优先搜索": {"key": ["深度优先搜索"], "property": ["type"], "to_name": ["图的遍历"], "重要程度": [4], "所属章节": ["7"], "知识点描述": ["深度优先搜索，其别名又叫DFS，属于图算法的一种。利用深度优先搜索算法可以产生目标图的相应拓扑排序表，利用拓扑排序表可以方便的解决很多相关的图论问题，如最大路径问题等等。"]}, "广度优先搜索": {"key": ["广度优先搜索"], "property": ["type"], "to_name": ["图的遍历"], "重要程度": [4], "所属章节": ["7"], "知识点描述": ["广度优先搜索，其别名又叫BFS，属于一种盲目搜寻法，是连通图的一种遍历算法这一算法也是很多重要的图的算法的原型。"]}, "树的遍历": {"key": ["树的遍历"], "property": ["type"], "to_name": ["基本操作"], "重要程度": [4], "所属章节": ["6"], "知识点描述": ["树的遍历是树的一种重要的运算。所谓遍历是指对树中所有结点的信息的访问，即依次对树中每个结点访问一次且仅访问一次。树的3种最重要的遍历方式分别称为前序遍历、中序遍历和后序遍历。"]}, "先根遍历树": {"key": ["先根遍历树"], "property": ["subclassof"], "to_name": ["树的遍历"], "重要程度": [4], "所属章节": ["6"], "知识点描述": ["先根遍历，也叫先序遍历，遍历的顺序是，根，左子树，右子树"]}, "中根遍历树": {"key": ["中根遍历树"], "property": ["subclassof"], "to_name": ["树的遍历"], "重要程度": [4], "所属章节": ["6"], "知识点描述": ["中根遍历，也叫中序遍历，顺序是左子树、根、右子树。"]}, "后根遍历树": {"key": ["后根遍历树"], "property": ["subclassof"], "to_name": ["树的遍历"], "重要程度": [4], "所属章节": ["6"], "知识点描述": ["后根遍历，也叫后序遍历，遍历顺序是左子树、右子树、根。"]}, "线索二叉树": {"key": ["线索二叉树"], "property": ["type"], "to_name": ["基本操作"], "重要程度": [2], "所属章节": ["6"], "知识点描述": ["对于n个结点的二叉树，在二叉链存储结构中有n+1个空链域，利用这些空链域存放在某种遍历次序下该结点的前驱结点和后继结点的指针，这些指针称为线索，加上线索的二叉树称为线索二叉树。根据线索性质的不同，线索二叉树可分为前序线索二叉树、中序线索二叉树和后序线索二叉树三种。"]}, "先序线索二叉树": {"key": ["先序线索二叉树"], "property": ["type"], "to_name": ["线索二叉树"], "重要程度": [2], "所属章节": ["6"], "知识点描述": ["在先序线索二叉树中查找结点的后继较容易，而查找前驱要知道其双亲的信息，要使用栈，所以说先序线索二叉树是不完善的。"]}, "中序线索二叉树": {"key": ["中序线索二叉树"], "property": ["type"], "to_name": ["线索二叉树"], "重要程度": [2], "所属章节": ["6"], "知识点描述": ["若结点的ltag=1，lchild指向其前驱;否则，该结点的前驱是以该结点为根的左子树上按中序遍历的最后一个结点。若rtag=1，rchild指向其后继;否则，该结点的后继是以该结点为根的右子树上按中序遍历的第一个结点。"]}, "后序线索二叉树": {"key": ["后序线索二叉树"], "property": ["type"], "to_name": ["线索二叉树"], "重要程度": [2], "所属章节": ["6"], "知识点描述": ["在后序线索二叉树中查找结点*p的前驱:若结点*p无左子树，则p->lchild指向其前驱;否则，若结点*p有左子树，当其右子树为空时，其左子树的根(即p->lrchild)为其后序前驱。当其右子树非空时，其右子树的根(即p->rchild)为其后序前驱。"]}, "基本算法": {"key": ["基本算法"], "property": ["subclassof"], "to_name": ["name"], "重要程度": [4], "所属章节": [" "], "知识点描述": []}, "排序算法": {"key": ["排序算法"], "property": ["subclassof"], "to_name": ["name"], "重要程度": [4], "所属章节": ["10"], "知识点描述": ["所谓排序算法，即通过特定的算法因式将一组或多组数据按照既定模式进行重新排序。"]}, "内部排序": {"key": ["内部排序"], "property": ["type"], "to_name": ["排序算法"], "重要程度": [4], "所属章节": ["10"], "知识点描述": ["内部排序是指待排序列完全存放在内存中所进行的排序过程，适合不太大的元素序列。内部排序方法:1.插入排序(直接插入排序);2.快速排序;3.选择排序(简单选择排序);4.归并排序 ;5.冒泡排序;6.希尔排序;希尔排序是对直接插入排序方法的改进。7.堆排序;8.基数排序;\n\n"]}, "交换排序": {"key": ["交换排序"], "property": ["type"], "to_name": ["内部排序"], "重要程度": [4], "所属章节": ["10"], "知识点描述": ["所谓交换，就是根据序列中两个记录键值的比较结果来对换这两个记录在序列中的位置，交换排序的特点是:将键值较大的记录向序列的尾部移动，键值较小的记录向序列的前部移动。"]}, "冒泡排序": {"key": ["冒泡排序"], "property": ["type"], "to_name": ["交换排序"], "重要程度": [4], "所属章节": ["10"], "知识点描述": ["每一趟只能确定将一个数归位，如果有n个数进行排序，只需将n-1个数归位，也就是说要进行n-1趟操作，而每一趟都需要从第1位开始进行相邻两个数的比较。"]}, "快速排序": {"key": ["快速排序"], "property": ["type"], "to_name": ["交换排序"], "重要程度": [4], "所属章节": ["10"], "知识点描述": ["通过一趟排序将要排序的数据分割成独立的两部分，分割点左边都是比它小的数，右边都是比它大的数。然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。"]}, "基数排序": {"key": ["基数排序"], "property": ["type"], "to_name": ["内部排序"], "重要程度": [4], "所属章节": ["10"], "知识点描述": ["将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列。"]}, "归并排序": {"key": ["归并排序"], "property": ["type"], "to_name": ["内部排序"], "重要程度": [4], "所属章节": ["10"], "知识点描述": ["将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。归并排序是一种稳定的排序方法。"]}}